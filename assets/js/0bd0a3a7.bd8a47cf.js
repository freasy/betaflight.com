"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4394],{3905:(e,r,t)=>{t.d(r,{Zo:()=>d,kt:()=>m});var a=t(67294);function n(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function o(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);r&&(a=a.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,a)}return t}function i(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?o(Object(t),!0).forEach((function(r){n(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,a,n=function(e,r){if(null==e)return{};var t,a,n={},o=Object.keys(e);for(a=0;a<o.length;a++)t=o[a],r.indexOf(t)>=0||(n[t]=e[t]);return n}(e,r);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)t=o[a],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var l=a.createContext({}),p=function(e){var r=a.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):i(i({},r),e)),t},d=function(e){var r=p(e.components);return a.createElement(l.Provider,{value:r},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var r=e.children;return a.createElement(a.Fragment,{},r)}},h=a.forwardRef((function(e,r){var t=e.components,n=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=p(t),h=n,m=u["".concat(l,".").concat(h)]||u[h]||c[h]||o;return t?a.createElement(m,i(i({ref:r},d),{},{components:t})):a.createElement(m,i({ref:r},d))}));function m(e,r){var t=arguments,n=r&&r.mdxType;if("string"==typeof e||n){var o=t.length,i=new Array(o);i[0]=h;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s[u]="string"==typeof e?e:n,i[1]=s;for(var p=2;p<o;p++)i[p]=t[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,t)}h.displayName="MDXCreateElement"},71775:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=t(87462),n=(t(67294),t(3905));const o={},i="Parameter Groups",s={unversionedId:"development/ParameterGroups",id:"development/ParameterGroups",title:"Parameter Groups",description:"Introduction",source:"@site/docs/development/ParameterGroups.md",sourceDirName:"development",slug:"/development/ParameterGroups",permalink:"/docs/development/ParameterGroups",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"development",previous:{title:"Parameter Group IDs",permalink:"/docs/development/Parameter-Group-IDs"},next:{title:"Profiles (aka PID Profiles)",permalink:"/docs/development/Profiles"}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Rules",id:"rules",level:2}],d={toc:p};function u(e){let{components:r,...t}=e;return(0,n.kt)("wrapper",(0,a.Z)({},d,t,{components:r,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"parameter-groups"},"Parameter Groups"),(0,n.kt)("h2",{id:"introduction"},"Introduction"),(0,n.kt)("p",null,"'Parameter Groups' is the name of the pattern that is used in Betaflight to store (and at a later point transfer) firmware configuration data."),(0,n.kt)("p",null,"With parameter groups, parameters are combined in logical groups (e.g. all the parameters for one particular device / feature go into one parameter group). These groups are modelled as data structures in the firmware."),(0,n.kt)("h2",{id:"rules"},"Rules"),(0,n.kt)("p",null,"The following rules have to be taken into consideration when dealing with parameter groups in code:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Each feature or group of related features, hardware driver or group of related hardware drivers should use a parameter group of its own;"),(0,n.kt)("li",{parentName:"ol"},"A parameter group of any given ID and version shall be identical across all targets and build configurations - this means that nothing that is contained in a parameter group directly or indirectly can be conditional. The finest granularity for parameters to be available on a given target is by having or not having support for a given parameter group;"),(0,n.kt)("li",{parentName:"ol"},"The only exception to 2. are parameter group arrays. For parameter group arrays, it is permissible to have the length of the array defined conditionally. Because the length of the struct defining the array elements is fixed for any given version, and the overall size of the array is stored with the array, the length of the array can be calculated when reading it. This consideration only applies to parameter group arrays declared with ",(0,n.kt)("inlineCode",{parentName:"li"},"PG_DECLARE_ARRAY"),", and the length supplied in the declaration. For the length of any arrays inside a parameter group struct (directly or nested), 2. applies;"),(0,n.kt)("li",{parentName:"ol"},"As a consequence of 1. and 2., all of the parameters required for the configuration of the feature or driver should be contained within this parameter group. If a parameter is required by more than one feature or driver, it shall be moved 'upwards' into a generic parameter group that all the features or drivers requiring the parameter depend upon - if necessary such a parameter group has to be created;"),(0,n.kt)("li",{parentName:"ol"},"New parameters should always be appended at the end of the parameter group. If this is the only change to the parameter group, there are no further changes required. Previously stored versions of the data in this parameter group can still be read. New elements will be initialised to 0 in this case. If 0 is an invalid value for a new parameter, this has to be treated as described in 6., in order to ensure the parameter is initialised to a valid value. If the parameter group that the new parameter is appended to is a parameter group array declared with ",(0,n.kt)("inlineCode",{parentName:"li"},"PG_DECLARE_ARRAY"),", then the version of the parameter group has to be incremented as described in 6. as well, in order get the change in the struct properly handled;"),(0,n.kt)("li",{parentName:"ol"},"Any changes to a parameter group that are not covered in 5. (e.g. removing elements, changing the type of elements), the version of the parameter group (as defined in ",(0,n.kt)("inlineCode",{parentName:"li"},"PG_REGISTER..."),") has to be incremented in order to make the code handling parameter groups aware that the format of the parameter group has changed and previously stored versions of it are now invalid;"),(0,n.kt)("li",{parentName:"ol"},"All changes to parameter group arrays (declared with ",(0,n.kt)("inlineCode",{parentName:"li"},"PG_DECLARE_ARRAY()"),") or arrays contained within the struct of a parameter group require that the version of the parameter group (as defined in ",(0,n.kt)("inlineCode",{parentName:"li"},"PG_REGISTER..")," has to be incremented as well, and the same considerations as for 6. apply;"),(0,n.kt)("li",{parentName:"ol"},"When creating a new parameter group, the ",(0,n.kt)("inlineCode",{parentName:"li"},"PG_DECLARE()")," / ",(0,n.kt)("inlineCode",{parentName:"li"},"PG_DECLARE_ARRAY()")," shall be placed right after the definition of the struct used as the type of the parameter group in the code. This serves the purpose of making it easy for developers to determine when a struct they are working on is used in a parameter group and subject to these rules;"),(0,n.kt)("li",{parentName:"ol"},"Any struct that is used as an element in a struct that is used in a parameter group (directly or indirectly) is subject to constraints 6. and 7. above. In order to make it possible for developers to determine that this is the case, a comment ",(0,n.kt)("inlineCode",{parentName:"li"},"// Used in parameter group <group name>")," shall be added after the definition of the struct for every parameter group that the struct is used in.")))}u.isMDXComponent=!0}}]);