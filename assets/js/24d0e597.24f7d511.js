"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[911],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>b});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),m=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=m(e.components);return r.createElement(l.Provider,{value:n},e.children)},p="mdxType",d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=m(t),u=a,b=p["".concat(l,".").concat(u)]||p[u]||d[u]||i;return t?r.createElement(b,o(o({ref:n},c),{},{components:t})):r.createElement(b,o({ref:n},c))}));function b(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=u;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s[p]="string"==typeof e?e:a,o[1]=s;for(var m=2;m<i;m++)o[m]=t[m];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},44150:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>m});var r=t(87462),a=(t(67294),t(3905));const i={},o="Atomic Barrier implementation",s={unversionedId:"development/development/Atomic Barrier",id:"development/development/Atomic Barrier",title:"Atomic Barrier implementation",description:"The ATOMICBLOCK/ATOMICBARRIER construction is dependent on gcc extensions. I relies on gcc cleanup function (attribute ((cleanup))) and assumes that cleanup handler is called, when leaving block, even when associated variable is eliminated.",source:"@site/docs/development/development/Atomic Barrier.md",sourceDirName:"development/development",slug:"/development/development/Atomic Barrier",permalink:"/docs/development/development/Atomic Barrier",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"development",previous:{title:"Development",permalink:"/docs/development/development/"},next:{title:"Contributing to Betaflight",permalink:"/docs/development/development/Betaflight-Contribution"}},l={},m=[],c={toc:m};function p(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"atomic-barrier-implementation"},"Atomic Barrier implementation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'static int markme_bar = 0;\nstatic int markme = 0;\n\nmarkme++;\n// (1) markme is read into register, but not changed\nmarkme_bar++;\n// markme_bar is read from memory and incremented\nATOMIC_BLOCK_NB(NVIC_PRIO_TIMER) {\n   ATOMIC_BARRIER(markme_bar);\n// start of ATOMIC_BLOCK_NB scope:\n//  markme_bar is stored into memory (it is input/output - "+m" output operand - of asm volatile)\n//  BASEPRI is saved into temporary variable\n//  BASEPRI_MAX is decremented to NVIC_PRIO_TIMER (if it is higher than NVIC_PRIO_TIMER or zero; lower number means higher priority on ARM)\n   markme++;\n// nothing happens, markme value is not needed yet\n   markme_bar++;\n// (2) markme_bar re-read from memory (ATOMIC_BARRIER marked it as modified - "+m" output operand of asm volatile)\n//  and incremented\n\n// end of ATOMIC_BLOCK_NB scope:\n//  markme_bar is stored into memory (cleanup function from ATOMIC_BARRIER) / input "m" operand), but kept for later use in register\n//    (actually markme_bar+1 is stored and pre-increment value kept in register)\n// BASEPRI value is restored\n};\n\nmarkme++;\n// register value read in (1) is incremented by 3\nmarkme_bar++;\n// register value read in (2) is incremented (actually +=2, because register contains pre-increment value)\n\n// markme and markme_bar are stored into memory\n')),(0,a.kt)("h1",{id:"atomic-barrier-warning"},"Atomic Barrier Warning"),(0,a.kt)("p",null,"The ATOMIC_BLOCK/ATOMIC_BARRIER construction is dependent on gcc extensions. I relies on gcc cleanup function (",(0,a.kt)("inlineCode",{parentName:"p"},"attribute ((cleanup))"),") and assumes that cleanup handler is called, when leaving block, even when associated variable is eliminated."),(0,a.kt)("p",null,"There is (a bit paranoid) safeguard warning to make sure that generated assembly is hand-checked on new gcc version. It is assumed that only major gcc version versions need to be checked."),(0,a.kt)("p",null,"If GCC is upgraded and a warning appears when compiling then the generated asm source must be verified."),(0,a.kt)("p",null,"e.g."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'%% serial_softserial.c\nwarning "Please verify that ATOMIC_BARRIER works as intended"\n')),(0,a.kt)("p",null,"To perform the verification, proceed as per discusson on issue #167 which reads:"),(0,a.kt)("p",null,"I hope it's enough to check that optimized-away variable still has cleanup code at end of scope."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"static int markme=0;\nmarkme++;\nATOMIC_BLOCK_NB(0xff) {\n   ATOMIC_BARRIER(markme);\n   markme++;\n};\nmarkme++;\n")),(0,a.kt)("p",null,"pass ",(0,a.kt)("inlineCode",{parentName:"p"},"-save-temps=obj")," (or ",(0,a.kt)("inlineCode",{parentName:"p"},"-save-temps=cwd"),", but lots of files will end up in same directory as makefile) to gcc link step (LTO is in use), find resulting ",(0,a.kt)("inlineCode",{parentName:"p"},"*.ltrans*.ltrans.s")," (grep for ",(0,a.kt)("inlineCode",{parentName:"p"},"markme"),", on linux it ends up in ",(0,a.kt)("inlineCode",{parentName:"p"},"/tmp"),") and check that generated assembly sequence is:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"                 MSR basepri_max, r3\n# (possibly markme address load)\n                # barier (markme) start\n\n# (increment markme, load and store to memory)\n        ldr     r2, [r3]\n        adds    r0, r2, #1\n        str     r0, [r3]\n\n                # barier(markme)  end\n                MSR basepri, r3\n\n# (markme value should be cached in register on next increment)\n")),(0,a.kt)("p",null,"The # barrier(markme) must surround access code and must be inside MSR basepri instructions ."),(0,a.kt)("p",null,"Similar approach is used for ATOMIC_BLOCK in avr libraries, so gcc should not break this behavior."),(0,a.kt)("p",null,"IMO attribute(cleanup) and asm volatile is defined in a way that should guarantee this."),(0,a.kt)("p",null,"attribute(cleanup) is probably safer way to implement atomic sections - another possibility is to explicitly place barriers in code, but that can (and will eventually) lead to missed barrier/basepri restore on same path creating very hard to find bug."),(0,a.kt)("p",null,"The 'MEMORY_BARRIER()' code can be omitted when 'ATOMIC_BLOCK' (with full memory barriers) is used, but it is better to explicitly state what memory is protected by barrier. gcc 5 can use this knowledge to greatly improve generated code."))}p.isMDXComponent=!0}}]);